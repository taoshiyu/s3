import FormData from 'form-data';
import { Blob } from 'buffer';
export interface Cookie {
    name: string;
    value: string;
    path?: string;
    domain?: string;
    expires?: string;
    rawExpires?: string;
    maxAge?: number;
    secure?: boolean;
    httpOnly?: boolean;
    sameSite?: string;
    unparsed?: string;
}
export interface TimeoutOptions {
    requestTimeout: number;
    acknowledgementTimeout?: number;
}
export interface CycleTLSRequestOptions {
    headers?: {
        [key: string]: any;
    };
    cookies?: Array<object> | {
        [key: string]: string;
    };
    body?: string | URLSearchParams | FormData;
    responseType?: 'json' | 'text' | 'arraybuffer' | 'blob' | 'stream';
    ja3?: string;
    ja4r?: string;
    http2Fingerprint?: string;
    quicFingerprint?: string;
    disableGrease?: boolean;
    userAgent?: string;
    serverName?: string;
    proxy?: string;
    timeout?: number;
    disableRedirect?: boolean;
    headerOrder?: string[];
    orderAsProvided?: boolean;
    insecureSkipVerify?: boolean;
    forceHTTP1?: boolean;
    forceHTTP3?: boolean;
    protocol?: string;
}
export interface CycleTLSResponse {
    status: number;
    headers: {
        [key: string]: any;
    };
    data: any;
    finalUrl: string;
    json(): Promise<any>;
    text(): Promise<string>;
    arrayBuffer(): Promise<ArrayBuffer>;
    blob(): Promise<Blob>;
}
export interface WebSocketMessage {
    type: 'text' | 'binary' | 'close' | 'ping' | 'pong';
    data: string | Buffer;
}
export interface CycleTLSWebSocketResponse extends CycleTLSResponse {
    send(data: string | Buffer, isBinary?: boolean): Promise<void>;
    close(code?: number, reason?: string): Promise<void>;
    onMessage(callback: (message: WebSocketMessage) => void): void;
    onClose(callback: (code: number, reason: string) => void): void;
    onError(callback: (error: Error) => void): void;
}
export interface SSEEvent {
    id?: string;
    event?: string;
    data: string;
    retry?: number;
}
export interface CycleTLSSSEResponse extends CycleTLSResponse {
    events(): AsyncIterableIterator<SSEEvent>;
    onEvent(callback: (event: SSEEvent) => void): void;
    onError(callback: (error: Error) => void): void;
    close(): Promise<void>;
}
export interface CycleTLSClient {
    (url: string, options: CycleTLSRequestOptions, method?: "head" | "get" | "post" | "put" | "delete" | "trace" | "options" | "connect" | "patch"): Promise<CycleTLSResponse>;
    head(url: string, options: CycleTLSRequestOptions): Promise<CycleTLSResponse>;
    get(url: string, options: CycleTLSRequestOptions): Promise<CycleTLSResponse>;
    post(url: string, options: CycleTLSRequestOptions): Promise<CycleTLSResponse>;
    put(url: string, options: CycleTLSRequestOptions): Promise<CycleTLSResponse>;
    delete(url: string, options: CycleTLSRequestOptions): Promise<CycleTLSResponse>;
    trace(url: string, options: CycleTLSRequestOptions): Promise<CycleTLSResponse>;
    options(url: string, options: CycleTLSRequestOptions): Promise<CycleTLSResponse>;
    connect(url: string, options: CycleTLSRequestOptions): Promise<CycleTLSResponse>;
    patch(url: string, options: CycleTLSRequestOptions): Promise<CycleTLSResponse>;
    ws(url: string, options: CycleTLSRequestOptions): Promise<CycleTLSWebSocketResponse>;
    webSocket(url: string, options: CycleTLSRequestOptions): Promise<CycleTLSWebSocketResponse>;
    sse(url: string, options: CycleTLSRequestOptions): Promise<CycleTLSSSEResponse>;
    eventSource(url: string, options: CycleTLSRequestOptions): Promise<CycleTLSSSEResponse>;
    exit(): Promise<undefined>;
}
declare const initCycleTLS: (initOptions?: {
    port?: number;
    debug?: boolean;
    timeout?: number;
    executablePath?: string;
    autoExit?: boolean;
}) => Promise<CycleTLSClient>;
export default initCycleTLS;
