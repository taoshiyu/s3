"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const path_1 = __importDefault(require("path"));
const events_1 = require("events");
const ws_1 = __importDefault(require("ws"));
const http = __importStar(require("http"));
const os_1 = __importDefault(require("os"));
const form_data_1 = __importDefault(require("form-data"));
const stream_1 = require("stream");
const util_1 = require("util");
const stream_2 = __importDefault(require("stream"));
const buffer_1 = require("buffer");
const pipeline = (0, util_1.promisify)(stream_2.default.pipeline);
// Global instance manager for tracking shared instances by port
class InstanceManager {
    static instance;
    sharedInstances = new Map();
    static getInstance() {
        if (!InstanceManager.instance) {
            InstanceManager.instance = new InstanceManager();
        }
        return InstanceManager.instance;
    }
    async getOrCreateSharedInstance(port, debug, timeout, executablePath) {
        let sharedInstance = this.sharedInstances.get(port);
        if (!sharedInstance) {
            sharedInstance = new SharedInstance(port, debug, timeout, executablePath);
            this.sharedInstances.set(port, sharedInstance);
            // Initialize the shared instance
            await sharedInstance.initialize();
        }
        return sharedInstance;
    }
    async removeSharedInstance(port) {
        const sharedInstance = this.sharedInstances.get(port);
        if (sharedInstance) {
            await sharedInstance.cleanup();
            this.sharedInstances.delete(port);
        }
    }
    async cleanup() {
        const cleanupPromises = Array.from(this.sharedInstances.values()).map(instance => instance.cleanup());
        await Promise.all(cleanupPromises);
        this.sharedInstances.clear();
    }
}
// Manages one Go server process and multiple TypeScript client connections
class SharedInstance extends events_1.EventEmitter {
    child = null;
    server = null;
    clients = new Map();
    port;
    debug;
    timeout;
    executablePath;
    isHost = false;
    connectionTimeout = null;
    failedInitialization = false;
    isShuttingDown = false;
    httpServer = null;
    constructor(port, debug, timeout, executablePath) {
        super();
        this.port = port;
        this.debug = debug;
        this.timeout = timeout;
        this.executablePath = executablePath;
    }
    async initialize() {
        return new Promise((resolve, reject) => {
            this.checkSpawnedInstance(resolve, reject);
        });
    }
    checkSpawnedInstance(resolve, reject) {
        this.httpServer = http.createServer();
        this.httpServer.once('listening', () => {
            // Close the HTTP server immediately after it starts listening
            this.httpServer.close(() => {
                // Ensure all listeners are removed and server is nulled
                this.httpServer.removeAllListeners();
                this.httpServer = null;
                this.spawnServer();
                this.isHost = true;
                this.createClient(resolve, reject);
            });
        });
        this.httpServer.once('error', (err) => {
            // Ensure the HTTP server is closed if an error occurs
            if (this.httpServer) {
                try {
                    this.httpServer.close(() => {
                        this.httpServer.removeAllListeners();
                        this.httpServer = null;
                    });
                }
                catch (e) {
                    console.error("Error closing server on error:", e);
                    this.httpServer = null;
                }
            }
            this.createClient(resolve, reject);
            this.isHost = false;
        });
        // Start listening last so that the above listeners are in place
        this.httpServer.listen(this.port);
    }
    spawnServer() {
        const PLATFORM_BINARIES = {
            "win32": { "x64": "index.exe" },
            "linux": { "arm": "index-arm", "arm64": "index-arm64", "x64": "index" },
            "darwin": { "x64": "index-mac", "arm": "index-mac-arm", "arm64": "index-mac-arm64" },
            "freebsd": { "x64": "index-freebsd" }
        };
        const executableFilename = PLATFORM_BINARIES[process.platform]?.[os_1.default.arch()];
        if (!executableFilename) {
            this.cleanExit(new Error(`Unsupported architecture ${os_1.default.arch()} for ${process.platform}`));
            return;
        }
        this.handleSpawn(executableFilename);
    }
    handleSpawn(fileName) {
        try {
            // Determine the executable path
            let execPath;
            if (this.executablePath) {
                // If filePath is provided, use it directly
                execPath = this.executablePath;
            }
            else {
                // Otherwise, construct path relative to __dirname
                execPath = path_1.default.join(__dirname, fileName);
            }
            // Remove quotes as they're not needed and can cause issues on Windows
            execPath = execPath.replace(/"/g, '');
            // Verify file exists before attempting to spawn
            if (!require('fs').existsSync(execPath)) {
                throw new Error(`Executable not found at path: ${execPath}`);
            }
            const spawnOptions = {
                env: { WS_PORT: this.port.toString() },
                shell: process.platform !== "win32", // false for Windows, true for others
                windowsHide: true,
                detached: process.platform !== "win32",
                // Add cwd option to ensure proper working directory
                cwd: path_1.default.dirname(execPath)
            };
            this.child = (0, child_process_1.spawn)(execPath, [], spawnOptions);
            this.child.stdout.on("data", (stdout) => {
                console.log(stdout.toString());
            });
            this.child.stderr.on("data", (stderr) => {
                const errorMessage = stderr.toString();
                if (errorMessage.includes("Request_Id_On_The_Left")) {
                    const [requestId, error] = errorMessage.split("Request_Id_On_The_Left");
                    // Handle request-specific error
                }
                else {
                    // Only restart on truly fatal errors
                    const fatalErrorPattern = /panic|fatal error|runtime error|address already in use/i;
                    if (fatalErrorPattern.test(errorMessage)) {
                        // Critical error - restart the process
                        this.cleanExit(`Fatal error detected (please open an issue https://github.com/Danny-Dasilva/CycleTLS/issues/new/choose) -> ${errorMessage}`);
                        this.handleSpawn(fileName);
                    }
                    else {
                        // Non-fatal error - just log it for debugging
                        if (this.debug) {
                            console.log(`[DEBUG] stderr: ${errorMessage}`);
                        }
                        // Don't restart for non-fatal errors like read timeouts
                    }
                }
            });
            // Add error handler for spawn errors
            this.child.on('error', (error) => {
                console.error(`Failed to start subprocess: ${error.message}`);
                if (error.code === 'ENOENT') {
                    console.error(`Executable not found at: ${execPath}`);
                    console.error('Please ensure the executable exists and has correct permissions');
                }
                throw error;
            });
        }
        catch (error) {
            console.error(`Error in handleSpawn: ${error.message}`);
            throw error;
        }
    }
    createClient(resolve, reject) {
        const attemptConnection = () => {
            const server = new ws_1.default(`ws://localhost:${this.port}`);
            server.on("open", () => {
                // When connected, clear the connection timeout if it exists.
                if (this.connectionTimeout) {
                    clearTimeout(this.connectionTimeout);
                    this.connectionTimeout = null;
                }
                this.server = server;
                this.server.on("message", (data) => {
                    const packetBuffer = new PacketBuffer(data);
                    const requestID = packetBuffer.readString();
                    const method = packetBuffer.readString();
                    // Route message to the appropriate client based on request ID
                    const clientId = this.extractClientIdFromRequestId(requestID);
                    const client = this.clients.get(clientId);
                    if (client) {
                        if (method === "response") {
                            const statusCode = packetBuffer.readU16();
                            const headers = [];
                            const finalUrl = packetBuffer.readString();
                            const headersLength = packetBuffer.readU16();
                            for (let i = 0; i < headersLength; i++) {
                                const headerValues = [];
                                const headerName = packetBuffer.readString();
                                const valuesLength = packetBuffer.readU16();
                                for (let j = 0; j < valuesLength; j++) {
                                    headerValues.push(packetBuffer.readString());
                                }
                                headers.push([headerName, headerValues]);
                            }
                            client.emit(requestID, {
                                method,
                                data: {
                                    statusCode,
                                    finalUrl,
                                    headers: Object.fromEntries(headers),
                                },
                            });
                        }
                        if (method === "data") {
                            client.emit(requestID, {
                                method,
                                data: packetBuffer.readBytes(false),
                            });
                        }
                        if (method === "error") {
                            const statusCode = packetBuffer.readU16();
                            const errorMessage = packetBuffer.readString();
                            client.emit(requestID, {
                                method,
                                data: {
                                    statusCode,
                                    message: errorMessage,
                                },
                            });
                        }
                        if (method === "end") {
                            client.emit(requestID, { method });
                        }
                    }
                });
                resolve();
            });
            server.on("error", (err) => {
                // On error, remove the listeners and try again after a short delay.
                server.removeAllListeners();
                setTimeout(() => {
                    if (this.failedInitialization) {
                        return;
                    }
                    attemptConnection();
                }, 100);
            });
        };
        attemptConnection();
        // Store the timeout so that we can clear it when the connection succeeds.
        this.connectionTimeout = setTimeout(() => {
            this.failedInitialization = true;
            reject(`Could not connect to the CycleTLS instance within ${this.timeout}ms`);
        }, this.timeout);
    }
    extractClientIdFromRequestId(requestId) {
        // Request ID format: ${clientId}#${url}#${timestamp}-${random}
        return requestId.split('#')[0];
    }
    addClient(clientId, client) {
        this.clients.set(clientId, client);
    }
    removeClient(clientId) {
        this.clients.delete(clientId);
        // If no more clients, cleanup the shared instance
        if (this.clients.size === 0) {
            InstanceManager.getInstance().removeSharedInstance(this.port);
        }
    }
    async sendRequest(requestId, options) {
        // Check if options.body is URLSearchParams and convert to string
        if (options.body instanceof URLSearchParams) {
            options.body = options.body.toString();
        }
        // Check if options.body is FormData and convert to multipart format
        if (options.body instanceof form_data_1.default) {
            // Get headers with boundary from FormData
            const formHeaders = options.body.getHeaders();
            options.headers = { ...options.headers, ...formHeaders };
            // Convert FormData to string while preserving multipart format
            const formDataString = await new Promise((resolve, reject) => {
                const chunks = [];
                const form = options.body;
                form.on('data', (chunk) => {
                    chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
                });
                form.on('end', () => {
                    const result = Buffer.concat(chunks).toString('utf8');
                    resolve(result);
                });
                form.on('error', reject);
                // Force reading the stream
                form.resume();
            });
            options.body = formDataString;
        }
        if (this.server) {
            this.server.send(JSON.stringify({ requestId, options }));
        }
        else {
            throw new Error('WebSocket server not connected');
        }
    }
    async cancelRequest(requestId) {
        if (this.server) {
            this.server.send(JSON.stringify({ action: "cancel", requestId }));
        }
    }
    async cleanExit(message) {
        if (message)
            console.log(message);
        if (this.isShuttingDown)
            return;
        this.isShuttingDown = true;
        if (this.child) {
            if (process.platform === "win32") {
                try {
                    this.child.kill('SIGKILL');
                }
                catch (error) {
                    console.error("Error killing Windows process:", error);
                }
            }
            else {
                try {
                    process.kill(-this.child.pid, 'SIGKILL');
                }
                catch (error) {
                    if (error.code !== "ESRCH") {
                        console.error("Error killing process:", error);
                    }
                }
            }
        }
    }
    async cleanup() {
        // Clear any pending timeouts
        if (this.connectionTimeout) {
            clearTimeout(this.connectionTimeout);
            this.connectionTimeout = null;
        }
        // Close HTTP server if it exists
        if (this.httpServer) {
            try {
                this.httpServer.close();
                this.httpServer.removeAllListeners();
            }
            catch (error) {
                console.error("Error closing HTTP server:", error);
            }
            this.httpServer = null;
        }
        // Kill child process forcefully
        if (this.isHost && this.child) {
            if (process.platform === "win32") {
                try {
                    this.child.kill('SIGKILL');
                }
                catch (error) {
                    console.error("Error killing Windows process:", error);
                }
            }
            else {
                try {
                    process.kill(-this.child.pid, 'SIGKILL');
                }
                catch (error) {
                    if (error.code !== "ESRCH") {
                        console.error("Error killing process:", error);
                    }
                }
            }
            this.child = null;
        }
        // Force close the WebSocket immediately
        if (this.server) {
            try {
                this.server.removeAllListeners();
                this.server.terminate();
                this.server = null;
            }
            catch (error) {
                console.error("Error closing WebSocket:", error);
            }
        }
        // Notify all clients that the shared instance is shutting down
        for (const client of this.clients.values()) {
            client.emit('sharedInstanceClosed');
        }
        this.clients.clear();
        this.removeAllListeners();
    }
}
// Represents an individual client connection to a SharedInstance
class CycleTLSClientImpl extends events_1.EventEmitter {
    sharedInstance;
    clientId;
    connectionsByHost = new Map();
    constructor(sharedInstance) {
        super();
        this.sharedInstance = sharedInstance;
        this.clientId = `client-${Date.now()}-${Math.floor(10000 * Math.random())}`;
        // Register this client with the shared instance
        this.sharedInstance.addClient(this.clientId, this);
        // Listen for shared instance closure
        this.on('sharedInstanceClosed', () => {
            this.removeAllListeners();
        });
    }
    async request(url, options, method = "get") {
        // Track connection reuse by parsing the URL's host
        const urlObj = new URL(url);
        const hostKey = urlObj.host;
        const requestId = `${this.clientId}#${url}#${Date.now()}-${Math.floor(1000 * Math.random())}`;
        //set default options
        options ??= {};
        // Set default fingerprinting options - prefer JA3 if multiple options are provided
        if (!options?.ja3 && !options?.ja4r && !options?.http2Fingerprint && !options?.quicFingerprint) {
            options.ja3 = "771,4865-4867-4866-49195-49199-52393-52392-49196-49200-49162-49161-49171-49172-51-57-47-53-10,0-23-65281-10-11-35-16-5-51-43-13-45-28-21,29-23-24-25-256-257,0";
        }
        // Set default user agent
        if (!options?.userAgent) {
            options.userAgent = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.54 Safari/537.36";
        }
        // Set default request options
        if (!options?.body)
            options.body = "";
        if (!options?.proxy)
            options.proxy = "";
        if (!options?.insecureSkipVerify)
            options.insecureSkipVerify = false;
        if (!options?.forceHTTP1)
            options.forceHTTP1 = false;
        if (!options?.forceHTTP3)
            options.forceHTTP3 = false;
        if (!options?.responseType)
            options.responseType = 'json';
        if (!options?.protocol) {
            // Default to standard HTTP protocol
            options.protocol = ""; // Empty string means standard HTTP/HTTPS
        }
        //convert simple cookies
        const cookies = options?.cookies;
        if (typeof cookies === "object" && !Array.isArray(cookies) && cookies !== null) {
            const tempArr = [];
            for (const [key, value] of Object.entries(options.cookies)) {
                tempArr.push({ name: key, value: value });
            }
            options.cookies = tempArr;
        }
        // Track if we've connected to this host before for connection reuse
        const hasExistingConnection = this.connectionsByHost.has(hostKey);
        // Set the connection as tracked for this host
        this.connectionsByHost.set(hostKey, true);
        // Send request through shared instance
        await this.sharedInstance.sendRequest(requestId, {
            url,
            ...options,
            method,
            // Add metadata about connection reuse (will be ignored by Go if not implemented)
            _connectionReuse: hasExistingConnection ? "reuse" : "new",
            _hostKey: hostKey,
        });
        return new Promise((resolveRequest, rejectRequest) => {
            let responseMetadata = null;
            const handleMessage = async (response) => {
                if (response.method === "error") {
                    // Handle error before or during body read
                    // If we already have response metadata (headers sent successfully but body read failed),
                    // return the error with empty headers
                    const errorResponse = {
                        status: response.data.statusCode,
                        headers: responseMetadata ? responseMetadata.headers : {},
                        finalUrl: responseMetadata ? responseMetadata.finalUrl : url,
                        data: response.data.message,
                        json: async () => Promise.resolve({}),
                        text: async () => Promise.resolve(response.data.message),
                        arrayBuffer: async () => Promise.resolve(new ArrayBuffer(0)),
                        blob: async () => Promise.resolve(new buffer_1.Blob([response.data.message], { type: 'text/plain' }))
                    };
                    this.off(requestId, handleMessage);
                    resolveRequest(errorResponse);
                }
                else if (response.method === "response") {
                    // Store response metadata but don't resolve yet
                    responseMetadata = response.data;
                }
                else if (response.method === "data" || response.method === "end") {
                    // Now we have response metadata, set up stream handling
                    if (!responseMetadata)
                        return;
                    // Remove the message handler and set up stream handling
                    this.off(requestId, handleMessage);
                    const stream = new stream_1.Readable({ read() { } });
                    const handleClose = () => {
                        this.sharedInstance.cancelRequest(requestId);
                    };
                    let bodyReadError = null;
                    const handleData = (response) => {
                        if (response.method === "data") {
                            stream.push(Buffer.from(response.data));
                        }
                        else if (response.method === "error") {
                            // Handle error that occurred during body read - store it and close the stream
                            bodyReadError = {
                                statusCode: response.data.statusCode,
                                message: response.data.message
                            };
                            stream.push(null); // Close stream gracefully
                            stream.off("close", handleClose);
                            this.off(requestId, handleData);
                        }
                        else if (response.method === "end") {
                            stream.push(null);
                            stream.off("close", handleClose);
                            this.off(requestId, handleData);
                        }
                    };
                    stream.on("close", handleClose);
                    this.on(requestId, handleData);
                    // Push the current data/end message to the stream
                    handleData(response);
                    try {
                        // For stream responses, return live stream immediately without buffering
                        if (options.responseType === 'stream') {
                            // Create response methods that collect data when called
                            const createStreamResponseMethods = (liveStream) => ({
                                json: async () => {
                                    const buffer = await streamToBuffer(liveStream);
                                    return JSON.parse(buffer.toString('utf8'));
                                },
                                text: async () => {
                                    const buffer = await streamToBuffer(liveStream);
                                    return buffer.toString('utf8');
                                },
                                arrayBuffer: async () => {
                                    const buffer = await streamToBuffer(liveStream);
                                    return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
                                },
                                blob: async () => {
                                    const buffer = await streamToBuffer(liveStream);
                                    const contentType = responseMetadata.headers['content-type'] || responseMetadata.headers['Content-Type'] || 'application/octet-stream';
                                    return new buffer_1.Blob([buffer], { type: Array.isArray(contentType) ? contentType[0] : contentType });
                                }
                            });
                            // Return response immediately with live stream
                            const streamMethods = createStreamResponseMethods(stream);
                            resolveRequest({
                                status: responseMetadata.statusCode,
                                headers: responseMetadata.headers,
                                finalUrl: responseMetadata.finalUrl,
                                data: stream, // Return live stream directly
                                ...streamMethods
                            });
                        }
                        else {
                            // Get raw buffer first for response methods (existing behavior)
                            const rawBuffer = await streamToBuffer(stream);
                            // Check if there was an error during body read
                            if (bodyReadError) {
                                // Return error response instead of successful response
                                const errorResponse = {
                                    status: bodyReadError.statusCode,
                                    headers: {},
                                    finalUrl: url,
                                    data: bodyReadError.message,
                                    json: async () => Promise.resolve({}),
                                    text: async () => Promise.resolve(bodyReadError.message),
                                    arrayBuffer: async () => Promise.resolve(new ArrayBuffer(0)),
                                    blob: async () => Promise.resolve(new buffer_1.Blob([bodyReadError.message], { type: 'text/plain' }))
                                };
                                resolveRequest(errorResponse);
                                return;
                            }
                            // Parse data based on responseType for backward compatibility
                            const parsedData = await parseResponseData(new stream_1.Readable({
                                read() {
                                    this.push(rawBuffer);
                                    this.push(null);
                                }
                            }), options.responseType, responseMetadata.headers);
                            // Create response methods
                            const responseMethods = createResponseMethods(rawBuffer, responseMetadata.headers);
                            resolveRequest({
                                status: responseMetadata.statusCode,
                                headers: responseMetadata.headers,
                                finalUrl: responseMetadata.finalUrl,
                                data: parsedData,
                                ...responseMethods
                            });
                        }
                    }
                    catch (error) {
                        rejectRequest(error);
                    }
                }
            };
            this.on(requestId, handleMessage);
        });
    }
    // HTTP method implementations
    head(url, options) {
        return this.request(url, options, "head");
    }
    get(url, options) {
        return this.request(url, options, "get");
    }
    post(url, options) {
        return this.request(url, options, "post");
    }
    put(url, options) {
        return this.request(url, options, "put");
    }
    delete(url, options) {
        return this.request(url, options, "delete");
    }
    trace(url, options) {
        return this.request(url, options, "trace");
    }
    options(url, options) {
        return this.request(url, options, "options");
    }
    connect(url, options) {
        return this.request(url, options, "connect");
    }
    patch(url, options) {
        return this.request(url, options, "patch");
    }
    // WebSocket methods
    ws(url, options) {
        // Set WebSocket protocol
        options.protocol = "websocket";
        return this.request(url, options, "get");
    }
    webSocket(url, options) {
        return this.ws(url, options);
    }
    // Server-Sent Events methods
    sse(url, options) {
        // Set SSE protocol
        options.protocol = "sse";
        return this.request(url, options, "get");
    }
    eventSource(url, options) {
        return this.sse(url, options);
    }
    async exit() {
        // Remove this client from the shared instance
        this.sharedInstance.removeClient(this.clientId);
        // Clean up this client's event listeners
        this.removeAllListeners();
        return Promise.resolve(undefined);
    }
}
// Global cleanup handler for the entire process
let globalShuttingDown = false;
const globalCleanup = async () => {
    if (globalShuttingDown)
        return;
    globalShuttingDown = true;
    try {
        await InstanceManager.getInstance().cleanup();
    }
    catch (error) {
        console.error('Error during global cleanup:', error);
    }
};
// Set up process-wide cleanup handlers
process.once("SIGINT", globalCleanup);
process.once("SIGTERM", globalCleanup);
process.once("beforeExit", globalCleanup);
// Function to convert a stream into a string
async function streamToString(stream) {
    const chunks = [];
    await pipeline(stream, new stream_1.Writable({
        write(chunk, encoding, callback) {
            chunks.push(chunk);
            callback();
        }
    }));
    return Buffer.concat(chunks).toString('utf8');
}
// Utility function to convert stream to buffer
async function streamToBuffer(stream) {
    const chunks = [];
    return new Promise((resolve, reject) => {
        stream
            .on("data", (chunk) => chunks.push(chunk))
            .on("end", () => resolve(Buffer.concat(chunks)))
            .on("error", (err) => reject(err));
    });
}
// Parse response data based on responseType (Axios-style)
async function parseResponseData(stream, responseType = 'json', headers) {
    const buffer = await streamToBuffer(stream);
    switch (responseType) {
        case 'arraybuffer':
            return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
        case 'blob':
            const contentType = headers['content-type'] || headers['Content-Type'] || 'application/octet-stream';
            return new buffer_1.Blob([buffer], { type: Array.isArray(contentType) ? contentType[0] : contentType });
        case 'text':
            return buffer.toString('utf8');
        case 'stream':
            // Return the original stream (though it's already consumed)
            const newStream = new stream_1.Readable({ read() { } });
            newStream.push(buffer);
            newStream.push(null);
            return newStream;
        case 'json':
        default:
            try {
                return JSON.parse(buffer.toString('utf8'));
            }
            catch (error) {
                // If JSON parsing fails, return raw buffer (could be compressed)
                return buffer;
            }
    }
}
// Helper functions to create response parsing methods
function createResponseMethods(rawBuffer, headers) {
    return {
        json: async () => {
            try {
                return JSON.parse(rawBuffer.toString('utf8'));
            }
            catch (error) {
                throw new Error(`Failed to parse response as JSON: ${error.message}`);
            }
        },
        text: async () => {
            return rawBuffer.toString('utf8');
        },
        arrayBuffer: async () => {
            return rawBuffer.buffer.slice(rawBuffer.byteOffset, rawBuffer.byteOffset + rawBuffer.byteLength);
        },
        blob: async () => {
            const contentType = headers['content-type'] || headers['Content-Type'] || 'application/octet-stream';
            return new buffer_1.Blob([rawBuffer], { type: Array.isArray(contentType) ? contentType[0] : contentType });
        }
    };
}
class PacketBuffer {
    _data;
    _index;
    constructor(data) {
        this._data = data;
        this._index = 0;
    }
    readU8() {
        return this._data[this._index++];
    }
    readU16() {
        return this.readU8() << 8
            | this.readU8();
    }
    readU32() {
        return this.readU8() << 24
            | this.readU8() << 16
            | this.readU8() << 8
            | this.readU8();
    }
    readU64() {
        return this.readU8() << 56
            | this.readU8() << 48
            | this.readU8() << 40
            | this.readU8() << 32
            | this.readU8() << 24
            | this.readU8() << 16
            | this.readU8() << 8
            | this.readU8();
    }
    readBytes(is64) {
        const len = is64 ? this.readU64() : this.readU32();
        const bytes = this._data.subarray(this._index, this._index + len);
        this._index += len;
        return bytes;
    }
    readString(encoding) {
        const len = this.readU16();
        const bytes = this._data.subarray(this._index, this._index + len);
        this._index += len;
        return bytes.toString(encoding);
    }
}
const initCycleTLS = async (initOptions = {}) => {
    let { port, debug, timeout, executablePath, autoExit = true } = initOptions;
    if (!port)
        port = 9119;
    if (!debug)
        debug = false;
    if (!timeout)
        timeout = 20000;
    try {
        // Get or create shared instance for this port
        const sharedInstance = await InstanceManager.getInstance().getOrCreateSharedInstance(port, debug, timeout, executablePath);
        // Create a new client connected to the shared instance
        const client = new CycleTLSClientImpl(sharedInstance);
        // Create the public interface that matches the expected API
        const publicInterface = (() => {
            const CycleTLS = async (url, options, method = "get") => {
                return client.request(url, options, method);
            };
            // HTTP method functions
            CycleTLS.head = (url, options) => {
                return client.head(url, options);
            };
            CycleTLS.get = (url, options) => {
                return client.get(url, options);
            };
            CycleTLS.post = (url, options) => {
                return client.post(url, options);
            };
            CycleTLS.put = (url, options) => {
                return client.put(url, options);
            };
            CycleTLS.delete = (url, options) => {
                return client.delete(url, options);
            };
            CycleTLS.trace = (url, options) => {
                return client.trace(url, options);
            };
            CycleTLS.options = (url, options) => {
                return client.options(url, options);
            };
            CycleTLS.connect = (url, options) => {
                return client.connect(url, options);
            };
            CycleTLS.patch = (url, options) => {
                return client.patch(url, options);
            };
            // WebSocket methods
            CycleTLS.ws = (url, options) => {
                return client.ws(url, options);
            };
            CycleTLS.webSocket = (url, options) => {
                return client.webSocket(url, options);
            };
            // Server-Sent Events methods
            CycleTLS.sse = (url, options) => {
                return client.sse(url, options);
            };
            CycleTLS.eventSource = (url, options) => {
                return client.eventSource(url, options);
            };
            // Utility methods
            CycleTLS.exit = async () => {
                return client.exit();
            };
            return CycleTLS;
        })();
        return publicInterface;
    }
    catch (error) {
        throw new Error(`Failed to initialize CycleTLS: ${error.message}`);
    }
};
exports.default = initCycleTLS;
module.exports = initCycleTLS;
module.exports.default = initCycleTLS;
module.exports.__esModule = true;
